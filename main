#!/bin/bash
tokens=( "$@" )
declare -a stack

push() {
    local stack_size="${#stack[@]}"
    stack["$stack_size"]=$1
}

stack_prev_back() {
    local stack_size="${#stack[@]}"
    ((stack_size -= 2))
    if ((stack_size < 0)); then
        return_=""
    else
        return_="${stack[$stack_size]}"
    fi
}

stack_back() {
    local stack_size="${#stack[@]}"
    ((stack_size--))
    if ((stack_size < 0)); then
        return_=""
    else
        return_="${stack[$stack_size]}"
    fi
}

pop() {
    local stack_size="${#stack[@]}"
    ((stack_size--))

    if ((stack_size < 0)); then
        return_=""
    else
        return_="${stack[$stack_size]}"
        unset stack[$stack_size]
    fi
}

stack_size() {
    return_="${#stack[@]}"
}

stack_empty() {
    local size="${#stack[@]}"
    ((size <= 0))
}

stack_check_prev_back_equal() {
    if stack_empty; then 
        exit
    fi

    local token="$1"
    stack_prev_back
    if [[ "$return_" == "$token" ]]; then
        return 0
    fi
    return 1
}

is_operator() {
    local token="$1"
    case "$token" in
        '+' | '-') return 0;;
        '*' | '/') return 0;;
        '^') return 0;;
        'sin' | 'cos' | 'tan') return 0;;
        'log' | 'exp') return 0;;
        'sqrt') return 0;;
        *) return 1;;
    esac
}

is_unary() {
    local token="$1"
    case "$token" in 
        'sin' | 'cos' | 'tan') return 0;;
        'log' | 'exp') return 0;;
        'sqrt') return 0;;
        *) return 1;;
    esac
}

priority() {
    local op="$1"
    case "$op" in 
        '+' | '-') return_=0;;
        '*' | '/') return_=1;;
        '^') return_=2;;
        'sin' | 'cos' | 'tan') return_=3;;
        'log' | 'exp') return_=3;;
        'sqrt') return_=3;;
    esac
}

compute_one_operand() {
    local op="$1"
    local x="$2"
    case "$op" in
        'sin') push "$(sin "$x")";;
        'cos') push "$(cos "$x")";;
        'tan') push "$(tan "$x")";;
        'log') push "$(log "$x")";;
        'exp') push "$(exp "$x")";;
    esac
}

compute_two_operand() {
    local x="$1"
    local op="$2"
    local y="$3"
    case "$op" in
        '+') push "$(add "$x" "$y")";;
        '-') push "$(sub "$x" "$y")";;
        '*') push "$(mul "$x" "$y")";;
        '/') push "$(div "$x" "$y")";;
        '^') push "$(pow "$x" "$y")";;
    esac
}

compute() {
    pop
    local b="$return_"
    pop
    local op="$return_"
    if is_unary "$op"; then 
        compute_one_operand "$op" "$b"
        return 0
    fi
    pop
    local a="$return_"
    compute_two_operand "$a" "$op" "$b"
}

compute_until_unique() {
    while stack_size; ((return_ > 1)); do
        compute
    done
}

compute_until() {
    local until_token="$1"
    while ! stack_check_prev_back_equal "$until_token"
    do
        compute
    done
    # clear '('
    pop 
    local result="$return_"
    pop
    push "$result"
}

for token in "${tokens[@]}"; do 
    if [[ "$token" == ')' ]]; then 
        compute_until '('
        continue
    fi

    if ! is_operator "$token"; then
        push "$token"
        continue
    fi

    stack_back
    if ! is_number "$return_"; then
        push "$token"
        continue
    fi

    stack_prev_back
    prev_op="$return_"
    if ! is_operator "$prev_op" ; then
        push "$token"
        continue
    fi

    if ! is_unary "$prev_op"; then 
        priority "$token"
        p1="$return_"
        priority "$prev_op"
        p2="$return_"
        if ((p1 <= p2)); then
            compute
        fi
    else
        compute
    fi


    push "$token"
done

compute_until_unique

pop
round "$return_"
